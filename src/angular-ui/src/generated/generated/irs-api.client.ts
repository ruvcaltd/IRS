//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class IrsApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    agents_GetAvailableAgents(teamId: number): Observable<SwaggerResponse<AvailableAgentResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/teams/{teamId}/agents/available";
        if (teamId === undefined || teamId === null)
            throw new globalThis.Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_GetAvailableAgents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_GetAvailableAgents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AvailableAgentResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AvailableAgentResponse[]>>;
        }));
    }

    protected processAgents_GetAvailableAgents(response: HttpResponseBase): Observable<SwaggerResponse<AvailableAgentResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AvailableAgentResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AvailableAgentResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_ValidateAgent(teamId: number, request: CreateAgentRequest): Observable<SwaggerResponse<AgentValidationResponse>> {
        let url_ = this.baseUrl + "/api/v1/teams/{teamId}/agents/validate";
        if (teamId === undefined || teamId === null)
            throw new globalThis.Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_ValidateAgent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_ValidateAgent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgentValidationResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgentValidationResponse>>;
        }));
    }

    protected processAgents_ValidateAgent(response: HttpResponseBase): Observable<SwaggerResponse<AgentValidationResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgentValidationResponse.fromJS(resultData200);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgentValidationResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_EnqueueRun(pageAgentId: number): Observable<SwaggerResponse<AgentRunResponse>> {
        let url_ = this.baseUrl + "/api/v1/page-agents/{pageAgentId}/runs";
        if (pageAgentId === undefined || pageAgentId === null)
            throw new globalThis.Error("The parameter 'pageAgentId' must be defined.");
        url_ = url_.replace("{pageAgentId}", encodeURIComponent("" + pageAgentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_EnqueueRun(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_EnqueueRun(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgentRunResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgentRunResponse>>;
        }));
    }

    protected processAgents_EnqueueRun(response: HttpResponseBase): Observable<SwaggerResponse<AgentRunResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AgentRunResponse.fromJS(resultData201);
            return _observableOf(new SwaggerResponse(status, _headers, result201));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgentRunResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_GetRuns(pageAgentId: number): Observable<SwaggerResponse<AgentRunResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/page-agents/{pageAgentId}/runs";
        if (pageAgentId === undefined || pageAgentId === null)
            throw new globalThis.Error("The parameter 'pageAgentId' must be defined.");
        url_ = url_.replace("{pageAgentId}", encodeURIComponent("" + pageAgentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_GetRuns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_GetRuns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgentRunResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgentRunResponse[]>>;
        }));
    }

    protected processAgents_GetRuns(response: HttpResponseBase): Observable<SwaggerResponse<AgentRunResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AgentRunResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgentRunResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_CreateAgent(teamId: number, request: CreateAgentRequest): Observable<SwaggerResponse<AvailableAgentResponse>> {
        let url_ = this.baseUrl + "/api/v1/teams/{teamId}/agents";
        if (teamId === undefined || teamId === null)
            throw new globalThis.Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_CreateAgent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_CreateAgent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AvailableAgentResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AvailableAgentResponse>>;
        }));
    }

    protected processAgents_CreateAgent(response: HttpResponseBase): Observable<SwaggerResponse<AvailableAgentResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AvailableAgentResponse.fromJS(resultData201);
            return _observableOf(new SwaggerResponse(status, _headers, result201));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AvailableAgentResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_GetAgent(teamId: number, agentId: number): Observable<SwaggerResponse<AgentDetailResponse>> {
        let url_ = this.baseUrl + "/api/v1/teams/{teamId}/agents/{agentId}";
        if (teamId === undefined || teamId === null)
            throw new globalThis.Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        if (agentId === undefined || agentId === null)
            throw new globalThis.Error("The parameter 'agentId' must be defined.");
        url_ = url_.replace("{agentId}", encodeURIComponent("" + agentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_GetAgent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_GetAgent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgentDetailResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgentDetailResponse>>;
        }));
    }

    protected processAgents_GetAgent(response: HttpResponseBase): Observable<SwaggerResponse<AgentDetailResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgentDetailResponse.fromJS(resultData200);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgentDetailResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_UpdateAgent(teamId: number, agentId: number, request: CreateAgentRequest): Observable<SwaggerResponse<AvailableAgentResponse>> {
        let url_ = this.baseUrl + "/api/v1/teams/{teamId}/agents/{agentId}";
        if (teamId === undefined || teamId === null)
            throw new globalThis.Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        if (agentId === undefined || agentId === null)
            throw new globalThis.Error("The parameter 'agentId' must be defined.");
        url_ = url_.replace("{agentId}", encodeURIComponent("" + agentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_UpdateAgent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_UpdateAgent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AvailableAgentResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AvailableAgentResponse>>;
        }));
    }

    protected processAgents_UpdateAgent(response: HttpResponseBase): Observable<SwaggerResponse<AvailableAgentResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvailableAgentResponse.fromJS(resultData200);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AvailableAgentResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_AttachAgent(pageId: number, request: AttachAgentRequest): Observable<SwaggerResponse<PageAgentResponse>> {
        let url_ = this.baseUrl + "/api/v1/research-pages/{pageId}/agents";
        if (pageId === undefined || pageId === null)
            throw new globalThis.Error("The parameter 'pageId' must be defined.");
        url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_AttachAgent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_AttachAgent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PageAgentResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PageAgentResponse>>;
        }));
    }

    protected processAgents_AttachAgent(response: HttpResponseBase): Observable<SwaggerResponse<PageAgentResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PageAgentResponse.fromJS(resultData201);
            return _observableOf(new SwaggerResponse(status, _headers, result201));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PageAgentResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_GetPageAgents(pageId: number): Observable<SwaggerResponse<PageAgentResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/research-pages/{pageId}/agents";
        if (pageId === undefined || pageId === null)
            throw new globalThis.Error("The parameter 'pageId' must be defined.");
        url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_GetPageAgents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_GetPageAgents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PageAgentResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PageAgentResponse[]>>;
        }));
    }

    protected processAgents_GetPageAgents(response: HttpResponseBase): Observable<SwaggerResponse<PageAgentResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PageAgentResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PageAgentResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_AttachSectionAgent(sectionId: number, request: AttachAgentRequest): Observable<SwaggerResponse<SectionAgentResponse>> {
        let url_ = this.baseUrl + "/api/v1/sections/{sectionId}/agents";
        if (sectionId === undefined || sectionId === null)
            throw new globalThis.Error("The parameter 'sectionId' must be defined.");
        url_ = url_.replace("{sectionId}", encodeURIComponent("" + sectionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_AttachSectionAgent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_AttachSectionAgent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<SectionAgentResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<SectionAgentResponse>>;
        }));
    }

    protected processAgents_AttachSectionAgent(response: HttpResponseBase): Observable<SwaggerResponse<SectionAgentResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SectionAgentResponse.fromJS(resultData201);
            return _observableOf(new SwaggerResponse(status, _headers, result201));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<SectionAgentResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_GetSectionAgents(sectionId: number): Observable<SwaggerResponse<SectionAgentResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/sections/{sectionId}/agents";
        if (sectionId === undefined || sectionId === null)
            throw new globalThis.Error("The parameter 'sectionId' must be defined.");
        url_ = url_.replace("{sectionId}", encodeURIComponent("" + sectionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_GetSectionAgents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_GetSectionAgents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<SectionAgentResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<SectionAgentResponse[]>>;
        }));
    }

    protected processAgents_GetSectionAgents(response: HttpResponseBase): Observable<SwaggerResponse<SectionAgentResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SectionAgentResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<SectionAgentResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_ToggleEnabled(pageAgentId: number, request: ToggleAgentRequest): Observable<SwaggerResponse<PageAgentResponse>> {
        let url_ = this.baseUrl + "/api/v1/page-agents/{pageAgentId}/enabled";
        if (pageAgentId === undefined || pageAgentId === null)
            throw new globalThis.Error("The parameter 'pageAgentId' must be defined.");
        url_ = url_.replace("{pageAgentId}", encodeURIComponent("" + pageAgentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_ToggleEnabled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_ToggleEnabled(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<PageAgentResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<PageAgentResponse>>;
        }));
    }

    protected processAgents_ToggleEnabled(response: HttpResponseBase): Observable<SwaggerResponse<PageAgentResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageAgentResponse.fromJS(resultData200);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<PageAgentResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_ToggleSectionEnabled(sectionAgentId: number, request: ToggleAgentRequest): Observable<SwaggerResponse<SectionAgentResponse>> {
        let url_ = this.baseUrl + "/api/v1/section-agents/{sectionAgentId}/enabled";
        if (sectionAgentId === undefined || sectionAgentId === null)
            throw new globalThis.Error("The parameter 'sectionAgentId' must be defined.");
        url_ = url_.replace("{sectionAgentId}", encodeURIComponent("" + sectionAgentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_ToggleSectionEnabled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_ToggleSectionEnabled(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<SectionAgentResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<SectionAgentResponse>>;
        }));
    }

    protected processAgents_ToggleSectionEnabled(response: HttpResponseBase): Observable<SwaggerResponse<SectionAgentResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectionAgentResponse.fromJS(resultData200);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<SectionAgentResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_DeletePageAgent(pageAgentId: number): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/v1/page-agents/{pageAgentId}";
        if (pageAgentId === undefined || pageAgentId === null)
            throw new globalThis.Error("The parameter 'pageAgentId' must be defined.");
        url_ = url_.replace("{pageAgentId}", encodeURIComponent("" + pageAgentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_DeletePageAgent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_DeletePageAgent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processAgents_DeletePageAgent(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_DeleteSectionAgent(sectionAgentId: number): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/v1/section-agents/{sectionAgentId}";
        if (sectionAgentId === undefined || sectionAgentId === null)
            throw new globalThis.Error("The parameter 'sectionAgentId' must be defined.");
        url_ = url_.replace("{sectionAgentId}", encodeURIComponent("" + sectionAgentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_DeleteSectionAgent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_DeleteSectionAgent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processAgents_DeleteSectionAgent(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_GetLatestRun(pageAgentId: number): Observable<SwaggerResponse<AgentRunResponse>> {
        let url_ = this.baseUrl + "/api/v1/page-agents/{pageAgentId}/runs/latest";
        if (pageAgentId === undefined || pageAgentId === null)
            throw new globalThis.Error("The parameter 'pageAgentId' must be defined.");
        url_ = url_.replace("{pageAgentId}", encodeURIComponent("" + pageAgentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_GetLatestRun(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_GetLatestRun(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgentRunResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgentRunResponse>>;
        }));
    }

    protected processAgents_GetLatestRun(response: HttpResponseBase): Observable<SwaggerResponse<AgentRunResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgentRunResponse.fromJS(resultData200);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgentRunResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_EnqueueSectionRun(sectionAgentId: number): Observable<SwaggerResponse<AgentRunResponse>> {
        let url_ = this.baseUrl + "/api/v1/section-agents/{sectionAgentId}/runs";
        if (sectionAgentId === undefined || sectionAgentId === null)
            throw new globalThis.Error("The parameter 'sectionAgentId' must be defined.");
        url_ = url_.replace("{sectionAgentId}", encodeURIComponent("" + sectionAgentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_EnqueueSectionRun(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_EnqueueSectionRun(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgentRunResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgentRunResponse>>;
        }));
    }

    protected processAgents_EnqueueSectionRun(response: HttpResponseBase): Observable<SwaggerResponse<AgentRunResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AgentRunResponse.fromJS(resultData201);
            return _observableOf(new SwaggerResponse(status, _headers, result201));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgentRunResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    agents_GetSectionRuns(sectionAgentId: number): Observable<SwaggerResponse<AgentRunResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/section-agents/{sectionAgentId}/runs";
        if (sectionAgentId === undefined || sectionAgentId === null)
            throw new globalThis.Error("The parameter 'sectionAgentId' must be defined.");
        url_ = url_.replace("{sectionAgentId}", encodeURIComponent("" + sectionAgentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAgents_GetSectionRuns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAgents_GetSectionRuns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgentRunResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgentRunResponse[]>>;
        }));
    }

    protected processAgents_GetSectionRuns(response: HttpResponseBase): Observable<SwaggerResponse<AgentRunResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AgentRunResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgentRunResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    auth_Register(request: RegisterRequest): Observable<SwaggerResponse<AuthResponse>> {
        let url_ = this.baseUrl + "/api/v1/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Register(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Register(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AuthResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AuthResponse>>;
        }));
    }

    protected processAuth_Register(response: HttpResponseBase): Observable<SwaggerResponse<AuthResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AuthResponse.fromJS(resultData201);
            return _observableOf(new SwaggerResponse(status, _headers, result201));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AuthResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    auth_Login(request: LoginRequest): Observable<SwaggerResponse<AuthResponse>> {
        let url_ = this.baseUrl + "/api/v1/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Login(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Login(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AuthResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AuthResponse>>;
        }));
    }

    protected processAuth_Login(response: HttpResponseBase): Observable<SwaggerResponse<AuthResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResponse.fromJS(resultData200);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AuthResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    health_Get(): Observable<SwaggerResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHealth_Get(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHealth_Get(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<FileResponse>>;
        }));
    }

    protected processHealth_Get(response: HttpResponseBase): Observable<SwaggerResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new SwaggerResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<FileResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    llm_GetProviders(): Observable<SwaggerResponse<LlmProviderResponse[]>> {
        let url_ = this.baseUrl + "/api/Llm/providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLlm_GetProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLlm_GetProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<LlmProviderResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<LlmProviderResponse[]>>;
        }));
    }

    protected processLlm_GetProviders(response: HttpResponseBase): Observable<SwaggerResponse<LlmProviderResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LlmProviderResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<LlmProviderResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    llm_GetModels(providerId: number | null | undefined): Observable<SwaggerResponse<LlmModelResponse[]>> {
        let url_ = this.baseUrl + "/api/Llm/models?";
        if (providerId !== undefined && providerId !== null)
            url_ += "providerId=" + encodeURIComponent("" + providerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLlm_GetModels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLlm_GetModels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<LlmModelResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<LlmModelResponse[]>>;
        }));
    }

    protected processLlm_GetModels(response: HttpResponseBase): Observable<SwaggerResponse<LlmModelResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LlmModelResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<LlmModelResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    llm_GetGlobalConfig(): Observable<SwaggerResponse<GlobalLlmConfigResponse>> {
        let url_ = this.baseUrl + "/api/Llm/global-config";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLlm_GetGlobalConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLlm_GetGlobalConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<GlobalLlmConfigResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<GlobalLlmConfigResponse>>;
        }));
    }

    protected processLlm_GetGlobalConfig(response: HttpResponseBase): Observable<SwaggerResponse<GlobalLlmConfigResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GlobalLlmConfigResponse.fromJS(resultData200);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<GlobalLlmConfigResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    llm_UpdateGlobalConfig(request: UpdateGlobalLlmConfigRequest): Observable<SwaggerResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Llm/global-config";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLlm_UpdateGlobalConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLlm_UpdateGlobalConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<FileResponse>>;
        }));
    }

    protected processLlm_UpdateGlobalConfig(response: HttpResponseBase): Observable<SwaggerResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new SwaggerResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<FileResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    llm_GetAgentConfig(agentId: number): Observable<SwaggerResponse<AgentLlmConfigResponse>> {
        let url_ = this.baseUrl + "/api/Llm/agents/{agentId}/config";
        if (agentId === undefined || agentId === null)
            throw new globalThis.Error("The parameter 'agentId' must be defined.");
        url_ = url_.replace("{agentId}", encodeURIComponent("" + agentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLlm_GetAgentConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLlm_GetAgentConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgentLlmConfigResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgentLlmConfigResponse>>;
        }));
    }

    protected processLlm_GetAgentConfig(response: HttpResponseBase): Observable<SwaggerResponse<AgentLlmConfigResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgentLlmConfigResponse.fromJS(resultData200);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgentLlmConfigResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    llm_UpdateAgentConfig(agentId: number, request: UpdateAgentLlmConfigRequest): Observable<SwaggerResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Llm/agents/{agentId}/config";
        if (agentId === undefined || agentId === null)
            throw new globalThis.Error("The parameter 'agentId' must be defined.");
        url_ = url_.replace("{agentId}", encodeURIComponent("" + agentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLlm_UpdateAgentConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLlm_UpdateAgentConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<FileResponse>>;
        }));
    }

    protected processLlm_UpdateAgentConfig(response: HttpResponseBase): Observable<SwaggerResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new SwaggerResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<FileResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    researchPages_GetMy(): Observable<SwaggerResponse<ResearchPageListItemResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/research-pages/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResearchPages_GetMy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResearchPages_GetMy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ResearchPageListItemResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ResearchPageListItemResponse[]>>;
        }));
    }

    protected processResearchPages_GetMy(response: HttpResponseBase): Observable<SwaggerResponse<ResearchPageListItemResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResearchPageListItemResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ResearchPageListItemResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    researchPages_Create(request: CreateResearchPageRequest): Observable<SwaggerResponse<ResearchPageResponse>> {
        let url_ = this.baseUrl + "/api/v1/research-pages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResearchPages_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResearchPages_Create(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ResearchPageResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ResearchPageResponse>>;
        }));
    }

    protected processResearchPages_Create(response: HttpResponseBase): Observable<SwaggerResponse<ResearchPageResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResearchPageResponse.fromJS(resultData201);
            return _observableOf(new SwaggerResponse(status, _headers, result201));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ResearchPageResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    researchPages_GetById(id: number): Observable<SwaggerResponse<ResearchPageResponse>> {
        let url_ = this.baseUrl + "/api/v1/research-pages/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResearchPages_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResearchPages_GetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<ResearchPageResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<ResearchPageResponse>>;
        }));
    }

    protected processResearchPages_GetById(response: HttpResponseBase): Observable<SwaggerResponse<ResearchPageResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResearchPageResponse.fromJS(resultData200);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<ResearchPageResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    researchPages_Delete(id: number): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/v1/research-pages/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResearchPages_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResearchPages_Delete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processResearchPages_Delete(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    researchPages_RunAll(id: number): Observable<SwaggerResponse<AgentRunResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/research-pages/{id}/run-all";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResearchPages_RunAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResearchPages_RunAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<AgentRunResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<AgentRunResponse[]>>;
        }));
    }

    protected processResearchPages_RunAll(response: HttpResponseBase): Observable<SwaggerResponse<AgentRunResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AgentRunResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<AgentRunResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    researchPages_RecalculateScores(): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/v1/research-pages/recalculate-scores";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResearchPages_RecalculateScores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResearchPages_RecalculateScores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processResearchPages_RecalculateScores(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    sections_AddComment(sectionId: number, request: CreateCommentRequest): Observable<SwaggerResponse<CommentResponse>> {
        let url_ = this.baseUrl + "/api/v1/sections/{sectionId}/comments";
        if (sectionId === undefined || sectionId === null)
            throw new globalThis.Error("The parameter 'sectionId' must be defined.");
        url_ = url_.replace("{sectionId}", encodeURIComponent("" + sectionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSections_AddComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSections_AddComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<CommentResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<CommentResponse>>;
        }));
    }

    protected processSections_AddComment(response: HttpResponseBase): Observable<SwaggerResponse<CommentResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CommentResponse.fromJS(resultData201);
            return _observableOf(new SwaggerResponse(status, _headers, result201));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CommentResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    sections_GetComments(sectionId: number): Observable<SwaggerResponse<CommentResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/sections/{sectionId}/comments";
        if (sectionId === undefined || sectionId === null)
            throw new globalThis.Error("The parameter 'sectionId' must be defined.");
        url_ = url_.replace("{sectionId}", encodeURIComponent("" + sectionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSections_GetComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSections_GetComments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<CommentResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<CommentResponse[]>>;
        }));
    }

    protected processSections_GetComments(response: HttpResponseBase): Observable<SwaggerResponse<CommentResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommentResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<CommentResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    sections_CreateSection(researchPageId: number, request: CreateSectionRequest): Observable<SwaggerResponse<SectionResponse>> {
        let url_ = this.baseUrl + "/api/v1/sections/research-page/{researchPageId}";
        if (researchPageId === undefined || researchPageId === null)
            throw new globalThis.Error("The parameter 'researchPageId' must be defined.");
        url_ = url_.replace("{researchPageId}", encodeURIComponent("" + researchPageId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSections_CreateSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSections_CreateSection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<SectionResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<SectionResponse>>;
        }));
    }

    protected processSections_CreateSection(response: HttpResponseBase): Observable<SwaggerResponse<SectionResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SectionResponse.fromJS(resultData201);
            return _observableOf(new SwaggerResponse(status, _headers, result201));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<SectionResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    sections_DeleteSection(sectionId: number): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/v1/sections/{sectionId}";
        if (sectionId === undefined || sectionId === null)
            throw new globalThis.Error("The parameter 'sectionId' must be defined.");
        url_ = url_.replace("{sectionId}", encodeURIComponent("" + sectionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSections_DeleteSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSections_DeleteSection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processSections_DeleteSection(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return _observableOf(new SwaggerResponse(status, _headers, null as any));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    securities_Search(q: string | undefined): Observable<SwaggerResponse<SecuritySearchItem[]>> {
        let url_ = this.baseUrl + "/api/v1/securities/search?";
        if (q === null)
            throw new globalThis.Error("The parameter 'q' cannot be null.");
        else if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSecurities_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSecurities_Search(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<SecuritySearchItem[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<SecuritySearchItem[]>>;
        }));
    }

    protected processSecurities_Search(response: HttpResponseBase): Observable<SwaggerResponse<SecuritySearchItem[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecuritySearchItem.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<SecuritySearchItem[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    teams_CreateTeam(request: CreateTeamRequest): Observable<SwaggerResponse<TeamResponse>> {
        let url_ = this.baseUrl + "/api/v1/teams";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeams_CreateTeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeams_CreateTeam(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<TeamResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<TeamResponse>>;
        }));
    }

    protected processTeams_CreateTeam(response: HttpResponseBase): Observable<SwaggerResponse<TeamResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TeamResponse.fromJS(resultData201);
            return _observableOf(new SwaggerResponse(status, _headers, result201));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TeamResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    teams_GetUserTeams(): Observable<SwaggerResponse<TeamResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/teams";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeams_GetUserTeams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeams_GetUserTeams(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<TeamResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<TeamResponse[]>>;
        }));
    }

    protected processTeams_GetUserTeams(response: HttpResponseBase): Observable<SwaggerResponse<TeamResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeamResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TeamResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    teams_SearchTeams(query: string | undefined): Observable<SwaggerResponse<TeamResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/teams/search?";
        if (query === null)
            throw new globalThis.Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeams_SearchTeams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeams_SearchTeams(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<TeamResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<TeamResponse[]>>;
        }));
    }

    protected processTeams_SearchTeams(response: HttpResponseBase): Observable<SwaggerResponse<TeamResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeamResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TeamResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    teams_JoinTeam(request: JoinTeamRequest): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/v1/teams/join";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeams_JoinTeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeams_JoinTeam(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processTeams_JoinTeam(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 202) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    teams_GetPendingRequests(teamId: number): Observable<SwaggerResponse<TeamMemberResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/teams/{teamId}/requests";
        if (teamId === undefined || teamId === null)
            throw new globalThis.Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeams_GetPendingRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeams_GetPendingRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<TeamMemberResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<TeamMemberResponse[]>>;
        }));
    }

    protected processTeams_GetPendingRequests(response: HttpResponseBase): Observable<SwaggerResponse<TeamMemberResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeamMemberResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TeamMemberResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    teams_ApproveMember(teamId: number, requestUserId: number, request: ApproveMemberRequest): Observable<SwaggerResponse<TeamMemberResponse>> {
        let url_ = this.baseUrl + "/api/v1/teams/{teamId}/requests/{requestUserId}/approve";
        if (teamId === undefined || teamId === null)
            throw new globalThis.Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        if (requestUserId === undefined || requestUserId === null)
            throw new globalThis.Error("The parameter 'requestUserId' must be defined.");
        url_ = url_.replace("{requestUserId}", encodeURIComponent("" + requestUserId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeams_ApproveMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeams_ApproveMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<TeamMemberResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<TeamMemberResponse>>;
        }));
    }

    protected processTeams_ApproveMember(response: HttpResponseBase): Observable<SwaggerResponse<TeamMemberResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamMemberResponse.fromJS(resultData200);
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TeamMemberResponse>>(new SwaggerResponse(status, _headers, null as any));
    }

    teams_RejectMember(teamId: number, requestUserId: number): Observable<SwaggerResponse<void>> {
        let url_ = this.baseUrl + "/api/v1/teams/{teamId}/requests/{requestUserId}";
        if (teamId === undefined || teamId === null)
            throw new globalThis.Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        if (requestUserId === undefined || requestUserId === null)
            throw new globalThis.Error("The parameter 'requestUserId' must be defined.");
        url_ = url_.replace("{requestUserId}", encodeURIComponent("" + requestUserId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeams_RejectMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeams_RejectMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<void>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<void>>;
        }));
    }

    protected processTeams_RejectMember(response: HttpResponseBase): Observable<SwaggerResponse<void>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<void>>(new SwaggerResponse(status, _headers, null as any));
    }

    teams_GetTeamMembers(teamId: number): Observable<SwaggerResponse<TeamMemberResponse[]>> {
        let url_ = this.baseUrl + "/api/v1/teams/{teamId}/members";
        if (teamId === undefined || teamId === null)
            throw new globalThis.Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTeams_GetTeamMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTeams_GetTeamMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwaggerResponse<TeamMemberResponse[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwaggerResponse<TeamMemberResponse[]>>;
        }));
    }

    protected processTeams_GetTeamMembers(response: HttpResponseBase): Observable<SwaggerResponse<TeamMemberResponse[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TeamMemberResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(new SwaggerResponse(status, _headers, result200));
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwaggerResponse<TeamMemberResponse[]>>(new SwaggerResponse(status, _headers, null as any));
    }
}

export class AvailableAgentResponse implements IAvailableAgentResponse {
    id?: number;
    name?: string;
    visibility?: string;
    endpoint_url?: string;
    http_method?: string;
    description?: string | undefined;

    constructor(data?: IAvailableAgentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.visibility = _data["visibility"];
            this.endpoint_url = _data["endpoint_url"];
            this.http_method = _data["http_method"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AvailableAgentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableAgentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["visibility"] = this.visibility;
        data["endpoint_url"] = this.endpoint_url;
        data["http_method"] = this.http_method;
        data["description"] = this.description;
        return data;
    }
}

export interface IAvailableAgentResponse {
    id?: number;
    name?: string;
    visibility?: string;
    endpoint_url?: string;
    http_method?: string;
    description?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class AgentValidationResponse implements IAgentValidationResponse {
    is_valid?: boolean;
    log?: string | undefined;

    constructor(data?: IAgentValidationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.is_valid = _data["is_valid"];
            this.log = _data["log"];
        }
    }

    static fromJS(data: any): AgentValidationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AgentValidationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["is_valid"] = this.is_valid;
        data["log"] = this.log;
        return data;
    }
}

export interface IAgentValidationResponse {
    is_valid?: boolean;
    log?: string | undefined;
}

export class CreateAgentRequest implements ICreateAgentRequest {
    name!: string;
    description?: string | undefined;
    visibility!: string;
    endpoint_url!: string;
    http_method!: string;
    auth_type!: string;
    username?: string | undefined;
    password?: string | undefined;
    api_token?: string | undefined;
    login_endpoint_url?: string | undefined;
    request_body_template?: string | undefined;
    agent_instructions!: string;
    response_mapping?: string | undefined;
    version?: string | undefined;
    llm_model_id?: number | undefined;
    llm_api_key?: string | undefined;

    constructor(data?: ICreateAgentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.visibility = _data["visibility"];
            this.endpoint_url = _data["endpoint_url"];
            this.http_method = _data["http_method"];
            this.auth_type = _data["auth_type"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.api_token = _data["api_token"];
            this.login_endpoint_url = _data["login_endpoint_url"];
            this.request_body_template = _data["request_body_template"];
            this.agent_instructions = _data["agent_instructions"];
            this.response_mapping = _data["response_mapping"];
            this.version = _data["version"];
            this.llm_model_id = _data["llm_model_id"];
            this.llm_api_key = _data["llm_api_key"];
        }
    }

    static fromJS(data: any): CreateAgentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAgentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["visibility"] = this.visibility;
        data["endpoint_url"] = this.endpoint_url;
        data["http_method"] = this.http_method;
        data["auth_type"] = this.auth_type;
        data["username"] = this.username;
        data["password"] = this.password;
        data["api_token"] = this.api_token;
        data["login_endpoint_url"] = this.login_endpoint_url;
        data["request_body_template"] = this.request_body_template;
        data["agent_instructions"] = this.agent_instructions;
        data["response_mapping"] = this.response_mapping;
        data["version"] = this.version;
        data["llm_model_id"] = this.llm_model_id;
        data["llm_api_key"] = this.llm_api_key;
        return data;
    }
}

export interface ICreateAgentRequest {
    name: string;
    description?: string | undefined;
    visibility: string;
    endpoint_url: string;
    http_method: string;
    auth_type: string;
    username?: string | undefined;
    password?: string | undefined;
    api_token?: string | undefined;
    login_endpoint_url?: string | undefined;
    request_body_template?: string | undefined;
    agent_instructions: string;
    response_mapping?: string | undefined;
    version?: string | undefined;
    llm_model_id?: number | undefined;
    llm_api_key?: string | undefined;
}

export class AgentRunResponse implements IAgentRunResponse {
    id?: number;
    research_page_agent_id?: number | undefined;
    section_agent_id?: number | undefined;
    section_id?: number | undefined;
    status?: string;
    started_at?: Date | undefined;
    completed_at?: Date | undefined;
    output?: string | undefined;
    error?: string | undefined;

    constructor(data?: IAgentRunResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.research_page_agent_id = _data["research_page_agent_id"];
            this.section_agent_id = _data["section_agent_id"];
            this.section_id = _data["section_id"];
            this.status = _data["status"];
            this.started_at = _data["started_at"] ? new Date(_data["started_at"].toString()) : undefined as any;
            this.completed_at = _data["completed_at"] ? new Date(_data["completed_at"].toString()) : undefined as any;
            this.output = _data["output"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): AgentRunResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AgentRunResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["research_page_agent_id"] = this.research_page_agent_id;
        data["section_agent_id"] = this.section_agent_id;
        data["section_id"] = this.section_id;
        data["status"] = this.status;
        data["started_at"] = this.started_at ? this.started_at.toISOString() : undefined as any;
        data["completed_at"] = this.completed_at ? this.completed_at.toISOString() : undefined as any;
        data["output"] = this.output;
        data["error"] = this.error;
        return data;
    }
}

export interface IAgentRunResponse {
    id?: number;
    research_page_agent_id?: number | undefined;
    section_agent_id?: number | undefined;
    section_id?: number | undefined;
    status?: string;
    started_at?: Date | undefined;
    completed_at?: Date | undefined;
    output?: string | undefined;
    error?: string | undefined;
}

export class AgentDetailResponse implements IAgentDetailResponse {
    id?: number;
    name?: string;
    description?: string | undefined;
    visibility?: string;
    endpoint_url?: string;
    http_method?: string;
    auth_type?: string;
    username?: string | undefined;
    has_password?: boolean;
    has_api_token?: boolean;
    login_endpoint_url?: string | undefined;
    request_body_template?: string | undefined;
    agent_instructions?: string;
    response_mapping?: string | undefined;
    version?: string | undefined;
    created_at?: Date | undefined;
    updated_at?: Date | undefined;
    llm_model_id?: number | undefined;
    has_llm_api_key?: boolean;

    constructor(data?: IAgentDetailResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.visibility = _data["visibility"];
            this.endpoint_url = _data["endpoint_url"];
            this.http_method = _data["http_method"];
            this.auth_type = _data["auth_type"];
            this.username = _data["username"];
            this.has_password = _data["has_password"];
            this.has_api_token = _data["has_api_token"];
            this.login_endpoint_url = _data["login_endpoint_url"];
            this.request_body_template = _data["request_body_template"];
            this.agent_instructions = _data["agent_instructions"];
            this.response_mapping = _data["response_mapping"];
            this.version = _data["version"];
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : undefined as any;
            this.updated_at = _data["updated_at"] ? new Date(_data["updated_at"].toString()) : undefined as any;
            this.llm_model_id = _data["llm_model_id"];
            this.has_llm_api_key = _data["has_llm_api_key"];
        }
    }

    static fromJS(data: any): AgentDetailResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AgentDetailResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["visibility"] = this.visibility;
        data["endpoint_url"] = this.endpoint_url;
        data["http_method"] = this.http_method;
        data["auth_type"] = this.auth_type;
        data["username"] = this.username;
        data["has_password"] = this.has_password;
        data["has_api_token"] = this.has_api_token;
        data["login_endpoint_url"] = this.login_endpoint_url;
        data["request_body_template"] = this.request_body_template;
        data["agent_instructions"] = this.agent_instructions;
        data["response_mapping"] = this.response_mapping;
        data["version"] = this.version;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : undefined as any;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : undefined as any;
        data["llm_model_id"] = this.llm_model_id;
        data["has_llm_api_key"] = this.has_llm_api_key;
        return data;
    }
}

export interface IAgentDetailResponse {
    id?: number;
    name?: string;
    description?: string | undefined;
    visibility?: string;
    endpoint_url?: string;
    http_method?: string;
    auth_type?: string;
    username?: string | undefined;
    has_password?: boolean;
    has_api_token?: boolean;
    login_endpoint_url?: string | undefined;
    request_body_template?: string | undefined;
    agent_instructions?: string;
    response_mapping?: string | undefined;
    version?: string | undefined;
    created_at?: Date | undefined;
    updated_at?: Date | undefined;
    llm_model_id?: number | undefined;
    has_llm_api_key?: boolean;
}

export class PageAgentResponse implements IPageAgentResponse {
    id?: number;
    agent_id?: number;
    name?: string;
    is_enabled?: boolean;
    last_run_status?: string | undefined;
    last_run_at?: Date | undefined;

    constructor(data?: IPageAgentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.agent_id = _data["agent_id"];
            this.name = _data["name"];
            this.is_enabled = _data["is_enabled"];
            this.last_run_status = _data["last_run_status"];
            this.last_run_at = _data["last_run_at"] ? new Date(_data["last_run_at"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): PageAgentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PageAgentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["agent_id"] = this.agent_id;
        data["name"] = this.name;
        data["is_enabled"] = this.is_enabled;
        data["last_run_status"] = this.last_run_status;
        data["last_run_at"] = this.last_run_at ? this.last_run_at.toISOString() : undefined as any;
        return data;
    }
}

export interface IPageAgentResponse {
    id?: number;
    agent_id?: number;
    name?: string;
    is_enabled?: boolean;
    last_run_status?: string | undefined;
    last_run_at?: Date | undefined;
}

export class AttachAgentRequest implements IAttachAgentRequest {
    agent_id!: number;

    constructor(data?: IAttachAgentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agent_id = _data["agent_id"];
        }
    }

    static fromJS(data: any): AttachAgentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AttachAgentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agent_id"] = this.agent_id;
        return data;
    }
}

export interface IAttachAgentRequest {
    agent_id: number;
}

export class SectionAgentResponse implements ISectionAgentResponse {
    id?: number;
    agent_id?: number;
    name?: string;
    is_enabled?: boolean;
    last_run_status?: string | undefined;
    last_run_at?: Date | undefined;

    constructor(data?: ISectionAgentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.agent_id = _data["agent_id"];
            this.name = _data["name"];
            this.is_enabled = _data["is_enabled"];
            this.last_run_status = _data["last_run_status"];
            this.last_run_at = _data["last_run_at"] ? new Date(_data["last_run_at"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): SectionAgentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SectionAgentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["agent_id"] = this.agent_id;
        data["name"] = this.name;
        data["is_enabled"] = this.is_enabled;
        data["last_run_status"] = this.last_run_status;
        data["last_run_at"] = this.last_run_at ? this.last_run_at.toISOString() : undefined as any;
        return data;
    }
}

export interface ISectionAgentResponse {
    id?: number;
    agent_id?: number;
    name?: string;
    is_enabled?: boolean;
    last_run_status?: string | undefined;
    last_run_at?: Date | undefined;
}

export class ToggleAgentRequest implements IToggleAgentRequest {
    is_enabled!: boolean;

    constructor(data?: IToggleAgentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.is_enabled = _data["is_enabled"];
        }
    }

    static fromJS(data: any): ToggleAgentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ToggleAgentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["is_enabled"] = this.is_enabled;
        return data;
    }
}

export interface IToggleAgentRequest {
    is_enabled: boolean;
}

export class AuthResponse implements IAuthResponse {
    userId?: number;
    email?: string;
    fullName?: string;
    token?: string;
    expiresIn?: number;

    constructor(data?: IAuthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.token = _data["token"];
            this.expiresIn = _data["expiresIn"];
        }
    }

    static fromJS(data: any): AuthResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["token"] = this.token;
        data["expiresIn"] = this.expiresIn;
        return data;
    }
}

export interface IAuthResponse {
    userId?: number;
    email?: string;
    fullName?: string;
    token?: string;
    expiresIn?: number;
}

export class RegisterRequest implements IRegisterRequest {
    email?: string;
    password?: string;
    fullName?: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["fullName"] = this.fullName;
        return data;
    }
}

export interface IRegisterRequest {
    email?: string;
    password?: string;
    fullName?: string;
}

export class LoginRequest implements ILoginRequest {
    email?: string;
    password?: string;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    email?: string;
    password?: string;
}

export class LlmProviderResponse implements ILlmProviderResponse {
    id?: number;
    name?: string;
    displayName?: string;
    isActive?: boolean;

    constructor(data?: ILlmProviderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): LlmProviderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LlmProviderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ILlmProviderResponse {
    id?: number;
    name?: string;
    displayName?: string;
    isActive?: boolean;
}

export class LlmModelResponse implements ILlmModelResponse {
    id?: number;
    providerId?: number;
    providerName?: string;
    modelIdentifier?: string;
    displayName?: string;
    isActive?: boolean;
    supportsStreaming?: boolean;
    supportsFunctionCalling?: boolean;
    supportsVision?: boolean;
    maxTokens?: number | undefined;
    contextWindow?: number | undefined;

    constructor(data?: ILlmModelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.providerId = _data["providerId"];
            this.providerName = _data["providerName"];
            this.modelIdentifier = _data["modelIdentifier"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.supportsStreaming = _data["supportsStreaming"];
            this.supportsFunctionCalling = _data["supportsFunctionCalling"];
            this.supportsVision = _data["supportsVision"];
            this.maxTokens = _data["maxTokens"];
            this.contextWindow = _data["contextWindow"];
        }
    }

    static fromJS(data: any): LlmModelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LlmModelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["providerId"] = this.providerId;
        data["providerName"] = this.providerName;
        data["modelIdentifier"] = this.modelIdentifier;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["supportsStreaming"] = this.supportsStreaming;
        data["supportsFunctionCalling"] = this.supportsFunctionCalling;
        data["supportsVision"] = this.supportsVision;
        data["maxTokens"] = this.maxTokens;
        data["contextWindow"] = this.contextWindow;
        return data;
    }
}

export interface ILlmModelResponse {
    id?: number;
    providerId?: number;
    providerName?: string;
    modelIdentifier?: string;
    displayName?: string;
    isActive?: boolean;
    supportsStreaming?: boolean;
    supportsFunctionCalling?: boolean;
    supportsVision?: boolean;
    maxTokens?: number | undefined;
    contextWindow?: number | undefined;
}

export class GlobalLlmConfigResponse implements IGlobalLlmConfigResponse {
    globalModelId?: number | undefined;
    modelDisplayName?: string | undefined;
    providerName?: string | undefined;
    hasApiKey?: boolean;
    updatedAt?: Date | undefined;
    updatedByUserId?: number | undefined;

    constructor(data?: IGlobalLlmConfigResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.globalModelId = _data["globalModelId"];
            this.modelDisplayName = _data["modelDisplayName"];
            this.providerName = _data["providerName"];
            this.hasApiKey = _data["hasApiKey"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.updatedByUserId = _data["updatedByUserId"];
        }
    }

    static fromJS(data: any): GlobalLlmConfigResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GlobalLlmConfigResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["globalModelId"] = this.globalModelId;
        data["modelDisplayName"] = this.modelDisplayName;
        data["providerName"] = this.providerName;
        data["hasApiKey"] = this.hasApiKey;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["updatedByUserId"] = this.updatedByUserId;
        return data;
    }
}

export interface IGlobalLlmConfigResponse {
    globalModelId?: number | undefined;
    modelDisplayName?: string | undefined;
    providerName?: string | undefined;
    hasApiKey?: boolean;
    updatedAt?: Date | undefined;
    updatedByUserId?: number | undefined;
}

export class UpdateGlobalLlmConfigRequest implements IUpdateGlobalLlmConfigRequest {
    globalModelId?: number | undefined;
    apiKey?: string | undefined;

    constructor(data?: IUpdateGlobalLlmConfigRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.globalModelId = _data["globalModelId"];
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): UpdateGlobalLlmConfigRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGlobalLlmConfigRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["globalModelId"] = this.globalModelId;
        data["apiKey"] = this.apiKey;
        return data;
    }
}

export interface IUpdateGlobalLlmConfigRequest {
    globalModelId?: number | undefined;
    apiKey?: string | undefined;
}

export class AgentLlmConfigResponse implements IAgentLlmConfigResponse {
    agentId?: number;
    llmModelId?: number | undefined;
    modelDisplayName?: string | undefined;
    providerName?: string | undefined;
    hasApiKey?: boolean;

    constructor(data?: IAgentLlmConfigResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agentId = _data["agentId"];
            this.llmModelId = _data["llmModelId"];
            this.modelDisplayName = _data["modelDisplayName"];
            this.providerName = _data["providerName"];
            this.hasApiKey = _data["hasApiKey"];
        }
    }

    static fromJS(data: any): AgentLlmConfigResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AgentLlmConfigResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agentId"] = this.agentId;
        data["llmModelId"] = this.llmModelId;
        data["modelDisplayName"] = this.modelDisplayName;
        data["providerName"] = this.providerName;
        data["hasApiKey"] = this.hasApiKey;
        return data;
    }
}

export interface IAgentLlmConfigResponse {
    agentId?: number;
    llmModelId?: number | undefined;
    modelDisplayName?: string | undefined;
    providerName?: string | undefined;
    hasApiKey?: boolean;
}

export class UpdateAgentLlmConfigRequest implements IUpdateAgentLlmConfigRequest {
    llmModelId?: number | undefined;
    apiKey?: string | undefined;

    constructor(data?: IUpdateAgentLlmConfigRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.llmModelId = _data["llmModelId"];
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): UpdateAgentLlmConfigRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAgentLlmConfigRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["llmModelId"] = this.llmModelId;
        data["apiKey"] = this.apiKey;
        return data;
    }
}

export interface IUpdateAgentLlmConfigRequest {
    llmModelId?: number | undefined;
    apiKey?: string | undefined;
}

export class ResearchPageListItemResponse implements IResearchPageListItemResponse {
    id?: number;
    team_id?: number;
    security_figi?: string;
    security_ticker?: string | undefined;
    security_name?: string | undefined;
    security_type?: string | undefined;
    conviction_score?: number | undefined;
    fundamental_score?: number | undefined;
    last_updated?: Date | undefined;

    constructor(data?: IResearchPageListItemResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.team_id = _data["team_id"];
            this.security_figi = _data["security_figi"];
            this.security_ticker = _data["security_ticker"];
            this.security_name = _data["security_name"];
            this.security_type = _data["security_type"];
            this.conviction_score = _data["conviction_score"];
            this.fundamental_score = _data["fundamental_score"];
            this.last_updated = _data["last_updated"] ? new Date(_data["last_updated"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ResearchPageListItemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchPageListItemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["team_id"] = this.team_id;
        data["security_figi"] = this.security_figi;
        data["security_ticker"] = this.security_ticker;
        data["security_name"] = this.security_name;
        data["security_type"] = this.security_type;
        data["conviction_score"] = this.conviction_score;
        data["fundamental_score"] = this.fundamental_score;
        data["last_updated"] = this.last_updated ? this.last_updated.toISOString() : undefined as any;
        return data;
    }
}

export interface IResearchPageListItemResponse {
    id?: number;
    team_id?: number;
    security_figi?: string;
    security_ticker?: string | undefined;
    security_name?: string | undefined;
    security_type?: string | undefined;
    conviction_score?: number | undefined;
    fundamental_score?: number | undefined;
    last_updated?: Date | undefined;
}

export class ResearchPageResponse implements IResearchPageResponse {
    id?: number;
    team_id?: number;
    security_figi?: string;
    security_ticker?: string | undefined;
    security_name?: string | undefined;
    security_type?: string | undefined;
    conviction_score?: number | undefined;
    fundamental_score?: number | undefined;
    last_updated?: Date | undefined;
    sections?: SectionResponse[];

    constructor(data?: IResearchPageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.team_id = _data["team_id"];
            this.security_figi = _data["security_figi"];
            this.security_ticker = _data["security_ticker"];
            this.security_name = _data["security_name"];
            this.security_type = _data["security_type"];
            this.conviction_score = _data["conviction_score"];
            this.fundamental_score = _data["fundamental_score"];
            this.last_updated = _data["last_updated"] ? new Date(_data["last_updated"].toString()) : undefined as any;
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(SectionResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResearchPageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchPageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["team_id"] = this.team_id;
        data["security_figi"] = this.security_figi;
        data["security_ticker"] = this.security_ticker;
        data["security_name"] = this.security_name;
        data["security_type"] = this.security_type;
        data["conviction_score"] = this.conviction_score;
        data["fundamental_score"] = this.fundamental_score;
        data["last_updated"] = this.last_updated ? this.last_updated.toISOString() : undefined as any;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IResearchPageResponse {
    id?: number;
    team_id?: number;
    security_figi?: string;
    security_ticker?: string | undefined;
    security_name?: string | undefined;
    security_type?: string | undefined;
    conviction_score?: number | undefined;
    fundamental_score?: number | undefined;
    last_updated?: Date | undefined;
    sections?: SectionResponse[];
}

export class SectionResponse implements ISectionResponse {
    id?: number;
    title?: string;
    fundamental_score?: number | undefined;
    conviction_score?: number | undefined;
    section_summary?: string | undefined;
    ai_generated_content?: string | undefined;

    constructor(data?: ISectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.fundamental_score = _data["fundamental_score"];
            this.conviction_score = _data["conviction_score"];
            this.section_summary = _data["section_summary"];
            this.ai_generated_content = _data["ai_generated_content"];
        }
    }

    static fromJS(data: any): SectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["fundamental_score"] = this.fundamental_score;
        data["conviction_score"] = this.conviction_score;
        data["section_summary"] = this.section_summary;
        data["ai_generated_content"] = this.ai_generated_content;
        return data;
    }
}

export interface ISectionResponse {
    id?: number;
    title?: string;
    fundamental_score?: number | undefined;
    conviction_score?: number | undefined;
    section_summary?: string | undefined;
    ai_generated_content?: string | undefined;
}

export class CreateResearchPageRequest implements ICreateResearchPageRequest {
    team_id!: number;
    figi!: string;
    ticker?: string | undefined;
    name?: string | undefined;
    security_type!: string;

    constructor(data?: ICreateResearchPageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.team_id = _data["team_id"];
            this.figi = _data["figi"];
            this.ticker = _data["ticker"];
            this.name = _data["name"];
            this.security_type = _data["security_type"];
        }
    }

    static fromJS(data: any): CreateResearchPageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateResearchPageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["team_id"] = this.team_id;
        data["figi"] = this.figi;
        data["ticker"] = this.ticker;
        data["name"] = this.name;
        data["security_type"] = this.security_type;
        return data;
    }
}

export interface ICreateResearchPageRequest {
    team_id: number;
    figi: string;
    ticker?: string | undefined;
    name?: string | undefined;
    security_type: string;
}

export class CommentResponse implements ICommentResponse {
    id?: number;
    section_id?: number;
    author_id?: number | undefined;
    author_type?: string | undefined;
    author_agent_name?: string | undefined;
    content?: string;
    created_at?: Date | undefined;

    constructor(data?: ICommentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.section_id = _data["section_id"];
            this.author_id = _data["author_id"];
            this.author_type = _data["author_type"];
            this.author_agent_name = _data["author_agent_name"];
            this.content = _data["content"];
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): CommentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CommentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["section_id"] = this.section_id;
        data["author_id"] = this.author_id;
        data["author_type"] = this.author_type;
        data["author_agent_name"] = this.author_agent_name;
        data["content"] = this.content;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : undefined as any;
        return data;
    }
}

export interface ICommentResponse {
    id?: number;
    section_id?: number;
    author_id?: number | undefined;
    author_type?: string | undefined;
    author_agent_name?: string | undefined;
    content?: string;
    created_at?: Date | undefined;
}

export class CreateCommentRequest implements ICreateCommentRequest {
    content!: string;

    constructor(data?: ICreateCommentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): CreateCommentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data;
    }
}

export interface ICreateCommentRequest {
    content: string;
}

export class CreateSectionRequest implements ICreateSectionRequest {
    title!: string;

    constructor(data?: ICreateSectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateSectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateSectionRequest {
    title: string;
}

export class SecuritySearchItem implements ISecuritySearchItem {
    figi?: string | undefined;
    ticker?: string | undefined;
    name?: string | undefined;
    market_sector?: string | undefined;
    security_type?: string | undefined;
    exchange_code?: string | undefined;
    mic_code?: string | undefined;
    share_class_figi?: string | undefined;
    composite_figi?: string | undefined;
    security_type2?: string | undefined;
    security_description?: string | undefined;

    constructor(data?: ISecuritySearchItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.figi = _data["figi"];
            this.ticker = _data["ticker"];
            this.name = _data["name"];
            this.market_sector = _data["market_sector"];
            this.security_type = _data["security_type"];
            this.exchange_code = _data["exchange_code"];
            this.mic_code = _data["mic_code"];
            this.share_class_figi = _data["share_class_figi"];
            this.composite_figi = _data["composite_figi"];
            this.security_type2 = _data["security_type2"];
            this.security_description = _data["security_description"];
        }
    }

    static fromJS(data: any): SecuritySearchItem {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySearchItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["figi"] = this.figi;
        data["ticker"] = this.ticker;
        data["name"] = this.name;
        data["market_sector"] = this.market_sector;
        data["security_type"] = this.security_type;
        data["exchange_code"] = this.exchange_code;
        data["mic_code"] = this.mic_code;
        data["share_class_figi"] = this.share_class_figi;
        data["composite_figi"] = this.composite_figi;
        data["security_type2"] = this.security_type2;
        data["security_description"] = this.security_description;
        return data;
    }
}

export interface ISecuritySearchItem {
    figi?: string | undefined;
    ticker?: string | undefined;
    name?: string | undefined;
    market_sector?: string | undefined;
    security_type?: string | undefined;
    exchange_code?: string | undefined;
    mic_code?: string | undefined;
    share_class_figi?: string | undefined;
    composite_figi?: string | undefined;
    security_type2?: string | undefined;
    security_description?: string | undefined;
}

export class TeamResponse implements ITeamResponse {
    id?: number;
    name?: string;
    created_at?: Date;
    current_user_role?: string;

    constructor(data?: ITeamResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : undefined as any;
            this.current_user_role = _data["current_user_role"];
        }
    }

    static fromJS(data: any): TeamResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TeamResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : undefined as any;
        data["current_user_role"] = this.current_user_role;
        return data;
    }
}

export interface ITeamResponse {
    id?: number;
    name?: string;
    created_at?: Date;
    current_user_role?: string;
}

export class CreateTeamRequest implements ICreateTeamRequest {
    name?: string;

    constructor(data?: ICreateTeamRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateTeamRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTeamRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateTeamRequest {
    name?: string;
}

export class JoinTeamRequest implements IJoinTeamRequest {
    team_id?: number;

    constructor(data?: IJoinTeamRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.team_id = _data["team_id"];
        }
    }

    static fromJS(data: any): JoinTeamRequest {
        data = typeof data === 'object' ? data : {};
        let result = new JoinTeamRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["team_id"] = this.team_id;
        return data;
    }
}

export interface IJoinTeamRequest {
    team_id?: number;
}

export class TeamMemberResponse implements ITeamMemberResponse {
    user_id?: number;
    team_id?: number;
    team_role_id?: number;
    team_role_name?: string;
    user_full_name?: string;
    user_email?: string;
    status?: string;
    created_at?: Date;

    constructor(data?: ITeamMemberResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_id = _data["user_id"];
            this.team_id = _data["team_id"];
            this.team_role_id = _data["team_role_id"];
            this.team_role_name = _data["team_role_name"];
            this.user_full_name = _data["user_full_name"];
            this.user_email = _data["user_email"];
            this.status = _data["status"];
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): TeamMemberResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TeamMemberResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id;
        data["team_id"] = this.team_id;
        data["team_role_id"] = this.team_role_id;
        data["team_role_name"] = this.team_role_name;
        data["user_full_name"] = this.user_full_name;
        data["user_email"] = this.user_email;
        data["status"] = this.status;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : undefined as any;
        return data;
    }
}

export interface ITeamMemberResponse {
    user_id?: number;
    team_id?: number;
    team_role_id?: number;
    team_role_name?: string;
    user_full_name?: string;
    user_email?: string;
    status?: string;
    created_at?: Date;
}

export class ApproveMemberRequest implements IApproveMemberRequest {
    user_id?: number;
    team_role_id?: number;

    constructor(data?: IApproveMemberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_id = _data["user_id"];
            this.team_role_id = _data["team_role_id"];
        }
    }

    static fromJS(data: any): ApproveMemberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveMemberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id;
        data["team_role_id"] = this.team_role_id;
        return data;
    }
}

export interface IApproveMemberRequest {
    user_id?: number;
    team_role_id?: number;
}

export class SwaggerResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}